local success, err = pcall(function()

if not game:IsLoaded() then game.Loaded:Wait() end

local UIS = game:GetService("UserInputService")
local IsMobile = UIS.TouchEnabled and not UIS.KeyboardEnabled

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

if not getgenv().ScriptState then
    getgenv().ScriptState = {
        isLockedOn = false,
        targetPlayer = nil,
        lockEnabled = false,
        smoothingFactor = 0.1,
        predictionFactor = 0.0,
        bodyPartSelected = "Head",
        ClosestHitPart = nil,
        previousHighlight = nil,
        lockedTime = 12,
        reverseResolveIntensity = 5,
        Desync = false,
        antiLockEnabled = false,
        resolverIntensity = 1.0,
        resolverMethod = "Recalculate",
        fovEnabled = false,
        fovMode = "Center",
        nebulaEnabled = false,
        fovValue = 70,
        SelfChamsEnabled = false,
        RainbowChamsEnabled = false,
        SelfChamsColor = Color3.fromRGB(255, 255, 255),
        ChamsEnabled = false,
        isSpeedActive = false,
        isFlyActive = false,
        isNoClipActive = false,
        flySpeed = 1,
        Cmultiplier = 1,
        lockTimeEnabled = false,
        aimLockVisibleCheck = false,
        aimLockAliveCheck = false,
        aimLockTeamCheck = false,
    }
end

local SilentAimSettings = {
    Enabled = false,
    TeamCheck = false,
    VisibleCheck = false,
    AliveCheck = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVVisible = false,
    ShowSilentAimTarget = false,
    HitChance = 100,
    MultiplyUnitBy = 1000,
    BulletTP = false,
}
getgenv().SilentAimSettings = SilentAimSettings

local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = 130
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = Color3.fromRGB(54, 57, 241)

local function CalculateChance(Percentage)
    return math.random(1, 100) <= Percentage
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = Camera:WorldToScreenPoint(Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function getFovOrigin()
    if ScriptState.fovMode == "Center" then
        local viewportSize = Camera.ViewportSize
        return Vector2.new(viewportSize.X / 2, viewportSize.Y / 2)
    end
    return UserInputService:GetMouseLocation()
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player and Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    if not (PlayerCharacter and LocalPlayerCharacter) then return false end
    local PlayerRoot = PlayerCharacter:FindFirstChild("HumanoidRootPart")
    if not PlayerRoot then return false end
    local CastPoints = { PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter }
    local IgnoreList = { LocalPlayerCharacter, PlayerCharacter }
    return #Camera:GetPartsObscuringTarget(CastPoints, IgnoreList) == 0
end

local function getClosestPlayer(config)
    config = config or {}
    local targetPartOption = config.targetPart or SilentAimSettings.TargetPart or "HumanoidRootPart"
    local radiusOption = config.radius or SilentAimSettings.FOVRadius or 2000
    local visibleCheck = config.visibleCheck or false
    local aliveCheck = config.aliveCheck or false
    local teamCheck = config.teamCheck or false
    local originPosition = getFovOrigin()

    local ClosestPart, ClosestPlayer, DistanceToMouse

    for _, Player in pairs(Players:GetPlayers()) do
        if Player == LocalPlayer then continue end
        if teamCheck and Player.Team == LocalPlayer.Team then continue end

        local Character = Player.Character
        if not Character then continue end

        local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = Character:FindFirstChild("Humanoid")
        if not HumanoidRootPart or not Humanoid then continue end

        if aliveCheck and Humanoid.Health <= 0 then continue end
        if visibleCheck and not IsPlayerVisible(Player) then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end

        local Distance = (originPosition - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or radiusOption) then
            local candidatePart = Character:FindFirstChild(targetPartOption) or Character:FindFirstChild("Head")
            if candidatePart then
                ClosestPart = candidatePart
                ClosestPlayer = Player
                DistanceToMouse = Distance
            end
        end
    end
    return ClosestPart, ClosestPlayer
end

local function acquireLockTarget()
    local _, player = getClosestPlayer({
        targetPart = ScriptState.bodyPartSelected,
        visibleCheck = ScriptState.aimLockVisibleCheck,
        aliveCheck = ScriptState.aimLockAliveCheck,
        teamCheck = ScriptState.aimLockTeamCheck
    })
    if player and player.Character then
        local partName = ScriptState.bodyPartSelected
        local targetPart = player.Character:FindFirstChild(partName) or player.Character:FindFirstChild("Head")
        if targetPart then
            ScriptState.isLockedOn = true
            ScriptState.targetPlayer = player
            return true
        end
    end
    ScriptState.isLockedOn = false
    ScriptState.targetPlayer = nil
    return false
end

local function toggleLock(state)
    ScriptState.lockEnabled = state
    if state then
        acquireLockTarget()
    else
        ScriptState.isLockedOn = false
        ScriptState.targetPlayer = nil
    end
end

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({
    Title = "PasteWare",
    Footer = "Obsidian Edition",
    Icon = 95816097006870,
    NotifySide = "Right",
    ShowCustomCursor = not IsMobile,
    AutoShow = true,
})

local Tabs = {
    Main = Window:AddTab("Main", "crosshair"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Exploits = Window:AddTab("Exploits", "zap"),
    Settings = Window:AddTab("Settings", "settings"),
}

local AimLockGroup = Tabs.Main:AddLeftGroupbox("AimLock")

AimLockGroup:AddToggle("AimLockToggle", {
    Text = "AimLock",
    Default = false,
    Callback = function(Value)
        toggleLock(Value)
    end
}):AddKeyPicker("AimLockKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "AimLock",
})

AimLockGroup:AddSlider("SmoothingSlider", {
    Text = "Camera Smoothing",
    Default = 0.1,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        ScriptState.smoothingFactor = Value
    end
})

AimLockGroup:AddSlider("PredictionSlider", {
    Text = "Prediction Factor",
    Default = 0.0,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Callback = function(Value)
        ScriptState.predictionFactor = Value
    end
})

AimLockGroup:AddToggle("AimVisibleCheck", {
    Text = "Visible Check",
    Default = false,
    Callback = function(Value)
        ScriptState.aimLockVisibleCheck = Value
    end
})

AimLockGroup:AddToggle("AimAliveCheck", {
    Text = "Alive Check",
    Default = false,
    Callback = function(Value)
        ScriptState.aimLockAliveCheck = Value
    end
})

AimLockGroup:AddToggle("AimTeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(Value)
        ScriptState.aimLockTeamCheck = Value
    end
})

AimLockGroup:AddDropdown("BodyPartDropdown", {
    Values = {"Head", "UpperTorso", "HumanoidRootPart"},
    Default = "Head",
    Text = "Target Part",
    Callback = function(Value)
        ScriptState.bodyPartSelected = Value
    end
})

local ResolverGroup = Tabs.Main:AddLeftGroupbox("Resolver")

ResolverGroup:AddToggle("AntiLockToggle", {
    Text = "Anti Lock Resolver",
    Default = false,
    Callback = function(Value)
        ScriptState.antiLockEnabled = Value
    end
})

ResolverGroup:AddSlider("ResolverIntensity", {
    Text = "Intensity",
    Default = 1.0,
    Min = 0,
    Max = 5,
    Rounding = 2,
    Callback = function(Value)
        ScriptState.resolverIntensity = Value
    end
})

ResolverGroup:AddDropdown("ResolverMethod", {
    Values = {"Recalculate", "Randomize", "Invert"},
    Default = "Recalculate",
    Text = "Method",
    Callback = function(Value)
        ScriptState.resolverMethod = Value
    end
})

local DesyncGroup = Tabs.Main:AddLeftGroupbox("Desync")

DesyncGroup:AddToggle("DesyncToggle", {
    Text = "Desync",
    Default = false,
    Callback = function(Value)
        ScriptState.Desync = Value
    end
}):AddKeyPicker("DesyncKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Desync",
})

DesyncGroup:AddSlider("DesyncIntensity", {
    Text = "Intensity",
    Default = 5,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Callback = function(Value)
        ScriptState.reverseResolveIntensity = Value
    end
})

local SilentAimGroup = Tabs.Main:AddRightGroupbox("Silent Aim")

SilentAimGroup:AddToggle("SilentAimToggle", {
    Text = "Silent Aim",
    Default = false,
    Callback = function(Value)
        SilentAimSettings.Enabled = Value
    end
}):AddKeyPicker("SilentAimKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Silent Aim",
})

SilentAimGroup:AddToggle("SilentTeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(Value)
        SilentAimSettings.TeamCheck = Value
    end
})

SilentAimGroup:AddToggle("SilentVisibleCheck", {
    Text = "Visible Check",
    Default = false,
    Callback = function(Value)
        SilentAimSettings.VisibleCheck = Value
    end
})

SilentAimGroup:AddToggle("SilentAliveCheck", {
    Text = "Alive Check",
    Default = false,
    Callback = function(Value)
        SilentAimSettings.AliveCheck = Value
    end
})

SilentAimGroup:AddToggle("BulletTPToggle", {
    Text = "Bullet Teleport",
    Default = false,
    Callback = function(Value)
        SilentAimSettings.BulletTP = Value
    end
})

SilentAimGroup:AddDropdown("SilentTargetPart", {
    Values = {"Head", "HumanoidRootPart"},
    Default = "HumanoidRootPart",
    Text = "Target Part",
    Callback = function(Value)
        SilentAimSettings.TargetPart = Value
    end
})

SilentAimGroup:AddDropdown("SilentMethod", {
    Values = {"Raycast", "FindPartOnRay", "FindPartOnRayWithIgnoreList"},
    Default = "Raycast",
    Text = "Method",
    Callback = function(Value)
        SilentAimSettings.SilentAimMethod = Value
    end
})

SilentAimGroup:AddSlider("HitChanceSlider", {
    Text = "Hit Chance",
    Default = 100,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        SilentAimSettings.HitChance = Value
    end
})

local FOVGroup = Tabs.Main:AddRightGroupbox("FOV Circle")

FOVGroup:AddToggle("FOVVisible", {
    Text = "Show FOV",
    Default = false,
    Callback = function(Value)
        fov_circle.Visible = Value
    end
}):AddColorPicker("FOVColor", {
    Default = Color3.fromRGB(54, 57, 241),
    Callback = function(Value)
        fov_circle.Color = Value
    end
})

FOVGroup:AddSlider("FOVRadius", {
    Text = "Radius",
    Default = 130,
    Min = 10,
    Max = 360,
    Rounding = 0,
    Callback = function(Value)
        fov_circle.Radius = Value
        SilentAimSettings.FOVRadius = Value
    end
})

FOVGroup:AddDropdown("FOVMode", {
    Values = {"Mouse", "Center"},
    Default = "Center",
    Text = "Origin",
    Callback = function(Value)
        ScriptState.fovMode = Value
    end
})

FOVGroup:AddToggle("ShowTarget", {
    Text = "Highlight Target",
    Default = false,
    Callback = function(Value)
        SilentAimSettings.ShowSilentAimTarget = Value
        if not Value and ScriptState.previousHighlight then
            ScriptState.previousHighlight:Destroy()
            ScriptState.previousHighlight = nil
        end
    end
}):AddColorPicker("TargetColor", {
    Default = Color3.fromRGB(255, 0, 255),
})

local MovementGroup = Tabs.Main:AddRightGroupbox("Movement")

MovementGroup:AddToggle("SpeedToggle", {
    Text = "CFrame Speed",
    Default = false,
    Callback = function(Value)
        ScriptState.isSpeedActive = Value
    end
}):AddKeyPicker("SpeedKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Speed",
})

MovementGroup:AddSlider("SpeedMultiplier", {
    Text = "Speed Value",
    Default = 1,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        ScriptState.Cmultiplier = Value
    end
})

MovementGroup:AddToggle("FlyToggle", {
    Text = "Fly",
    Default = false,
    Callback = function(Value)
        ScriptState.isFlyActive = Value
    end
}):AddKeyPicker("FlyKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Fly",
})

MovementGroup:AddSlider("FlySpeedSlider", {
    Text = "Fly Speed",
    Default = 1,
    Min = 1,
    Max = 20,
    Rounding = 1,
    Callback = function(Value)
        ScriptState.flySpeed = Value
    end
})

MovementGroup:AddToggle("NoClipToggle", {
    Text = "NoClip",
    Default = false,
    Callback = function(Value)
        ScriptState.isNoClipActive = Value
    end
}):AddKeyPicker("NoClipKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "NoClip",
})

local HitSoundGroup = Tabs.Main:AddLeftGroupbox("HitSound")

local sounds = {
    ["Neverlose"] = "rbxassetid://6565370984",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["Minecraft"] = "rbxassetid://5869422451",
    ["Bubble"] = "rbxassetid://9102092728",
}

local hitSound = Instance.new("Sound")
hitSound.Volume = 3
hitSound.Parent = SoundService
hitSound.SoundId = sounds["Neverlose"]

HitSoundGroup:AddToggle("HitSoundEnabled", {
    Text = "Enable HitSound",
    Default = false,
})

HitSoundGroup:AddDropdown("HitSoundSelect", {
    Values = {"Neverlose", "Gamesense", "Minecraft", "Bubble"},
    Default = "Neverlose",
    Text = "Sound",
    Callback = function(Value)
        hitSound.SoundId = sounds[Value] or sounds["Neverlose"]
    end
})

local ESPGroup = Tabs.Visuals:AddLeftGroupbox("ESP")

ESPGroup:AddToggle("ESPEnabled", {
    Text = "Enable ESP",
    Default = false,
    Callback = function(Value)
        if Value and not _G.ExunysESPLoaded then
            pcall(function()
                loadstring(game:HttpGet("https://raw.githubusercontent.com/FakeAngles/PasteWare-v2/refs/heads/main/ExLib.lua"))()
            end)
        end
        local ESP = getgenv().ExunysDeveloperESP
        if ESP and ESP.Settings then
            ESP.Settings.Enabled = Value
        end
    end
})

ESPGroup:AddToggle("ESPTeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(Value)
        local ESP = getgenv().ExunysDeveloperESP
        if ESP and ESP.Settings then
            ESP.Settings.TeamCheck = Value
        end
    end
})

ESPGroup:AddToggle("ESPBoxEnabled", {
    Text = "Box",
    Default = false,
    Callback = function(Value)
        local ESP = getgenv().ExunysDeveloperESP
        if ESP and ESP.Properties and ESP.Properties.Box then
            ESP.Properties.Box.Enabled = Value
        end
    end
})

ESPGroup:AddToggle("ESPTracerEnabled", {
    Text = "Tracer",
    Default = false,
    Callback = function(Value)
        local ESP = getgenv().ExunysDeveloperESP
        if ESP and ESP.Properties and ESP.Properties.Tracer then
            ESP.Properties.Tracer.Enabled = Value
        end
    end
})

ESPGroup:AddToggle("ESPHealthBar", {
    Text = "Health Bar",
    Default = false,
    Callback = function(Value)
        local ESP = getgenv().ExunysDeveloperESP
        if ESP and ESP.Properties and ESP.Properties.HealthBar then
            ESP.Properties.HealthBar.Enabled = Value
        end
    end
})

local ChamsGroup = Tabs.Visuals:AddLeftGroupbox("Chams")

ChamsGroup:AddToggle("ChamsEnabled", {
    Text = "Player Chams",
    Default = false,
    Callback = function(Value)
        ScriptState.ChamsEnabled = Value
    end
})

ChamsGroup:AddLabel("Visible Color"):AddColorPicker("ChamsVisibleColor", {
    Default = Color3.fromRGB(255, 0, 255),
})

ChamsGroup:AddLabel("Occluded Color"):AddColorPicker("ChamsOccludedColor", {
    Default = Color3.fromRGB(128, 0, 128),
})

local SelfChamsGroup = Tabs.Visuals:AddLeftGroupbox("Self Chams")

local originalProperties = {}

local function applySelfChams(char)
    if not char then return end
    originalProperties = {}
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            originalProperties[part] = { Color = part.Color, Material = part.Material }
            part.Material = Enum.Material.ForceField
            part.Color = ScriptState.SelfChamsColor
        end
    end
end

local function restoreSelfChams()
    for part, props in pairs(originalProperties) do
        if part and part.Parent then
            part.Color = props.Color
            part.Material = props.Material
        end
    end
    originalProperties = {}
end

SelfChamsGroup:AddToggle("SelfChamsEnabled", {
    Text = "Self Chams",
    Default = false,
    Callback = function(Value)
        ScriptState.SelfChamsEnabled = Value
        if Value then
            if LocalPlayer.Character then applySelfChams(LocalPlayer.Character) end
        else
            restoreSelfChams()
        end
    end
})

SelfChamsGroup:AddToggle("RainbowSelfChams", {
    Text = "Rainbow",
    Default = false,
    Callback = function(Value)
        ScriptState.RainbowChamsEnabled = Value
    end
})

SelfChamsGroup:AddLabel("Color"):AddColorPicker("SelfChamsColor", {
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(Value)
        ScriptState.SelfChamsColor = Value
    end
})

local WorldGroup = Tabs.Visuals:AddRightGroupbox("World")

WorldGroup:AddSlider("WorldTime", {
    Text = "Time",
    Default = 12,
    Min = 0,
    Max = 24,
    Rounding = 1,
    Callback = function(Value)
        ScriptState.lockedTime = Value
        if ScriptState.lockTimeEnabled then
            Lighting.ClockTime = Value
        end
    end
})

WorldGroup:AddToggle("LockTimeToggle", {
    Text = "Lock Time",
    Default = false,
    Callback = function(Value)
        ScriptState.lockTimeEnabled = Value
        if Value then Lighting.ClockTime = ScriptState.lockedTime end
    end
})

WorldGroup:AddSlider("CameraFOV", {
    Text = "Camera FOV",
    Default = 70,
    Min = 30,
    Max = 120,
    Rounding = 0,
    Callback = function(Value)
        ScriptState.fovValue = Value
    end
})

WorldGroup:AddToggle("FOVChangeToggle", {
    Text = "Change FOV",
    Default = false,
    Callback = function(Value)
        ScriptState.fovEnabled = Value
    end
})

local ACSGroup = Tabs.Exploits:AddLeftGroupbox("ACS Engine")

getgenv().WeaponOnHands = false
getgenv().WeaponModifyMethod = "Attribute"

local function modifyWeaponSettings(property, value)
    pcall(function()
        local character = LocalPlayer.Character
        local backpack = LocalPlayer:FindFirstChild("Backpack")
        if not character or not backpack then return end

        local function apply(weapon)
            if not weapon or not weapon:IsA("Tool") then return end
            if getgenv().WeaponModifyMethod == "Attribute" then
                weapon:SetAttribute(property, value)
            end
        end

        if getgenv().WeaponOnHands then
            local tool = character:FindFirstChildOfClass("Tool")
            if tool then apply(tool) end
        else
            for _, item in ipairs(backpack:GetChildren()) do apply(item) end
            local tool = character:FindFirstChildOfClass("Tool")
            if tool then apply(tool) end
        end
    end)
end

ACSGroup:AddToggle("WeaponOnHands", {
    Text = "Weapon In Hands Only",
    Default = false,
    Callback = function(Value)
        getgenv().WeaponOnHands = Value
    end
})

ACSGroup:AddButton({ Text = "Infinite Ammo", Func = function()
    modifyWeaponSettings("Ammo", math.huge)
    Library:Notify({ Title = "ACS", Description = "Applied", Time = 2 })
end })

ACSGroup:AddButton({ Text = "No Recoil", Func = function()
    modifyWeaponSettings("VRecoil", Vector2.new(0, 0))
    modifyWeaponSettings("HRecoil", Vector2.new(0, 0))
    modifyWeaponSettings("MinSpread", 0)
    modifyWeaponSettings("MaxSpread", 0)
    Library:Notify({ Title = "ACS", Description = "Applied", Time = 2 })
end })

ACSGroup:AddButton({ Text = "Infinite Range", Func = function()
    modifyWeaponSettings("Distance", 25000)
    Library:Notify({ Title = "ACS", Description = "Applied", Time = 2 })
end })

local MenuGroup = Tabs.Settings:AddLeftGroupbox("Menu")

MenuGroup:AddToggle("ShowKeybinds", {
    Text = "Show Keybinds",
    Default = false,
    Callback = function(Value)
        Library.KeybindFrame.Visible = Value
    end
})

MenuGroup:AddLabel("Menu Bind"):AddKeyPicker("MenuKeybind", {
    Default = "RightShift",
    NoUI = true,
    Text = "Menu",
})

MenuGroup:AddButton({ Text = "Unload", Func = function() Library:Unload() end })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
ThemeManager:SetFolder("PasteWare")
SaveManager:SetFolder("PasteWare/Configs")
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

local Connections = {}

Connections.AimLock = RunService.RenderStepped:Connect(function()
    pcall(function()
        if ScriptState.lockEnabled and not ScriptState.isLockedOn then
            acquireLockTarget()
        end

        if ScriptState.lockEnabled and ScriptState.isLockedOn and ScriptState.targetPlayer then
            local char = ScriptState.targetPlayer.Character
            if not char then
                ScriptState.isLockedOn = false
                ScriptState.targetPlayer = nil
                return
            end

            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if not humanoid or humanoid.Health <= 0 then
                ScriptState.isLockedOn = false
                ScriptState.targetPlayer = nil
                return
            end

            local part = char:FindFirstChild(ScriptState.bodyPartSelected) or char:FindFirstChild("Head")
            if not part then return end

            local predictedPos = part.Position + (part.AssemblyLinearVelocity * ScriptState.predictionFactor)

            if ScriptState.antiLockEnabled then
                if ScriptState.resolverMethod == "Recalculate" then
                    predictedPos = predictedPos + (part.AssemblyLinearVelocity * ScriptState.resolverIntensity)
                elseif ScriptState.resolverMethod == "Randomize" then
                    predictedPos = predictedPos + Vector3.new(
                        (math.random() - 0.5) * ScriptState.resolverIntensity,
                        (math.random() - 0.5) * ScriptState.resolverIntensity,
                        (math.random() - 0.5) * ScriptState.resolverIntensity
                    )
                elseif ScriptState.resolverMethod == "Invert" then
                    predictedPos = predictedPos - (part.AssemblyLinearVelocity * ScriptState.resolverIntensity * 2)
                end
            end

            Camera.CFrame = CFrame.new(Camera.CFrame.Position, predictedPos) * CFrame.new(0, 0, ScriptState.smoothingFactor)
        end
    end)
end)

Connections.SilentAim = RunService.Heartbeat:Connect(function()
    pcall(function()
        if SilentAimSettings.Enabled then
            ScriptState.ClosestHitPart = getClosestPlayer({
                targetPart = SilentAimSettings.TargetPart,
                visibleCheck = SilentAimSettings.VisibleCheck,
                teamCheck = SilentAimSettings.TeamCheck,
                aliveCheck = SilentAimSettings.AliveCheck
            })
        else
            ScriptState.ClosestHitPart = nil
        end
    end)
end)

Connections.FOV = RunService.RenderStepped:Connect(function()
    pcall(function()
        if fov_circle.Visible then
            fov_circle.Position = getFovOrigin()
        end

        if ScriptState.fovEnabled then
            Camera.FieldOfView = ScriptState.fovValue
        end
    end)
end)

Connections.Highlight = RunService.RenderStepped:Connect(function()
    pcall(function()
        if SilentAimSettings.ShowSilentAimTarget then
            local _, closestPlayer = getClosestPlayer()
            if closestPlayer and closestPlayer.Character then
                if ScriptState.previousHighlight then
                    ScriptState.previousHighlight:Destroy()
                end
                local highlight = Instance.new("Highlight")
                highlight.Parent = closestPlayer.Character
                highlight.Adornee = closestPlayer.Character
                highlight.FillColor = Options.TargetColor.Value
                highlight.FillTransparency = 0.5
                highlight.OutlineColor = Options.TargetColor.Value
                ScriptState.previousHighlight = highlight
            end
        end
    end)
end)

Connections.Movement = RunService.Heartbeat:Connect(function()
    pcall(function()
        local character = LocalPlayer.Character
        if not character then return end
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not rootPart then return end

        if ScriptState.isSpeedActive and humanoid then
            if humanoid.MoveDirection.Magnitude > 0 then
                rootPart.CFrame = rootPart.CFrame + humanoid.MoveDirection.Unit * ScriptState.Cmultiplier
            end
        end

        if ScriptState.isFlyActive then
            local dir = Vector3.zero
            if IsMobile then
                if humanoid and humanoid.MoveDirection.Magnitude > 0 then
                    dir = humanoid.MoveDirection.Unit
                end
            else
                if UserInputService:IsKeyDown(Enum.KeyCode.W) then dir = dir + Camera.CFrame.LookVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then dir = dir - Camera.CFrame.LookVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then dir = dir - Camera.CFrame.RightVector end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then dir = dir + Camera.CFrame.RightVector end
            end
            if dir.Magnitude > 0 then dir = dir.Unit end
            rootPart.CFrame = CFrame.new(rootPart.Position + dir * ScriptState.flySpeed)
            rootPart.AssemblyLinearVelocity = Vector3.zero
        end

        if ScriptState.isNoClipActive then
            for _, v in pairs(character:GetDescendants()) do
                if v:IsA("BasePart") then v.CanCollide = false end
            end
        end
    end)
end)

Connections.Desync = RunService.Heartbeat:Connect(function()
    pcall(function()
        if ScriptState.Desync then
            local character = LocalPlayer.Character
            if not character then return end
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local intensity = ScriptState.reverseResolveIntensity
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(math.random(-intensity, intensity)), 0)
        end
    end)
end)

Connections.SelfChams = RunService.RenderStepped:Connect(function()
    pcall(function()
        if ScriptState.SelfChamsEnabled then
            for part, _ in pairs(originalProperties) do
                if part and part.Parent then
                    if ScriptState.RainbowChamsEnabled then
                        part.Color = Color3.fromHSV((tick() % 5) / 5, 1, 1)
                    else
                        part.Color = ScriptState.SelfChamsColor
                    end
                end
            end
        end
    end)
end)

local ChamsCache = {}

Connections.Chams = RunService.RenderStepped:Connect(function()
    pcall(function()
        if not ScriptState.ChamsEnabled then
            for _, data in pairs(ChamsCache) do
                if data.highlight then data.highlight:Destroy() end
            end
            ChamsCache = {}
            return
        end

        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                if not ChamsCache[player] then
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = player.Character
                    highlight.Adornee = player.Character
                    ChamsCache[player] = { highlight = highlight }
                end
                local h = ChamsCache[player].highlight
                if h and h.Parent then
                    h.FillColor = Options.ChamsVisibleColor.Value
                    h.OutlineColor = Options.ChamsOccludedColor.Value
                    h.FillTransparency = 0.5
                end
            end
        end
    end)
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    if ScriptState.SelfChamsEnabled then
        applySelfChams(char)
    end
end)

pcall(function()
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
        local Method = getnamecallmethod()
        local Args = {...}
        local self = Args[1]

        if not SilentAimSettings.Enabled or checkcaller() then
            return oldNamecall(...)
        end

        if self ~= workspace then
            return oldNamecall(...)
        end

        if not CalculateChance(SilentAimSettings.HitChance) then
            return oldNamecall(...)
        end

        local HitPart = ScriptState.ClosestHitPart
        if not HitPart then
            return oldNamecall(...)
        end

        local function getDirection(origin)
            local adjusted = origin
            if SilentAimSettings.BulletTP then
                adjusted = (HitPart.CFrame * CFrame.new(0, 0, 1)).Position
            end
            return (HitPart.Position - adjusted).Unit * (SilentAimSettings.MultiplyUnitBy or 1000), adjusted
        end

        if Method == "Raycast" and SilentAimSettings.SilentAimMethod == "Raycast" then
            local dir, origin = getDirection(Args[2])
            Args[2] = origin
            Args[3] = dir
            return oldNamecall(unpack(Args))
        end

        if Method == "FindPartOnRayWithIgnoreList" then
            local ray = Args[2]
            if typeof(ray) == "Ray" then
                local dir, origin = getDirection(ray.Origin)
                Args[2] = Ray.new(origin, dir)
                return oldNamecall(unpack(Args))
            end
        end

        return oldNamecall(...)
    end))
end)

Library:OnUnload(function()
    for _, conn in pairs(Connections) do
        if conn then conn:Disconnect() end
    end
    fov_circle:Remove()
    if ScriptState.previousHighlight then
        ScriptState.previousHighlight:Destroy()
    end
    restoreSelfChams()
    for _, data in pairs(ChamsCache) do
        if data.highlight then data.highlight:Destroy() end
    end
end)

Library:Notify({ Title = "PasteWare", Description = "Loaded Successfully!", Time = 3 })

end)

if not success then
    warn("[PasteWare Error]", err)
end
