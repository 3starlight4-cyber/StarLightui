local success, err = pcall(function()

if not game:IsLoaded() then game.Loaded:Wait() end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local IsMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

getgenv().PasteWare = getgenv().PasteWare or {}
local PW = getgenv().PasteWare

PW.AimLock = {
    Enabled = false,
    Smoothness = 0.15,
    Prediction = 0.165,
    TargetPart = "Head",
    VisibleCheck = false,
    TeamCheck = false,
    AliveCheck = true,
    Target = nil,
    Locked = false,
}

PW.SilentAim = {
    Enabled = false,
    TargetPart = "HumanoidRootPart",
    Prediction = 0.165,
    HitChance = 100,
    VisibleCheck = false,
    TeamCheck = false,
    AliveCheck = true,
    Method = "Raycast",
    Target = nil,
}

PW.Resolver = {
    Enabled = false,
    Intensity = 1.5,
    Method = "Velocity",
}

PW.Desync = {
    Enabled = false,
    Intensity = 5,
    Mode = "Velocity",
}

PW.Movement = {
    SpeedEnabled = false,
    SpeedValue = 2,
    FlyEnabled = false,
    FlySpeed = 50,
    NoClipEnabled = false,
    InfiniteJumpEnabled = false,
    BodyVelocity = nil,
    BodyGyro = nil,
}

PW.Visuals = {
    ESPEnabled = false,
    ESPBox = true,
    ESPName = true,
    ESPHealth = true,
    ESPDistance = true,
    ESPTeamCheck = false,
    ESPColor = Color3.fromRGB(255, 0, 255),
    ChamsEnabled = false,
    FOVCircle = nil,
    FOVEnabled = false,
    FOVRadius = 150,
    FOVColor = Color3.fromRGB(255, 255, 255),
}

PW.World = {
    TimeEnabled = false,
    TimeValue = 12,
    FullbrightEnabled = false,
    NoFogEnabled = false,
    OriginalLighting = {},
}

PW.Misc = {
    AntiAFKEnabled = false,
    AutoRespawnEnabled = false,
}

PW.Connections = {}
PW.ESPObjects = {}

local function Disconnect(name)
    if PW.Connections[name] then
        PW.Connections[name]:Disconnect()
        PW.Connections[name] = nil
    end
end

local function DisconnectAll()
    for name, conn in pairs(PW.Connections) do
        if conn then pcall(function() conn:Disconnect() end) end
    end
    PW.Connections = {}
end

local function GetCharacter(player)
    return player and player.Character
end

local function GetHumanoid(player)
    local char = GetCharacter(player)
    return char and char:FindFirstChildOfClass("Humanoid")
end

local function GetRootPart(player)
    local char = GetCharacter(player)
    return char and (char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart)
end

local function IsAlive(player)
    local hum = GetHumanoid(player)
    return hum and hum.Health > 0
end

local function IsTeammate(player)
    if not player or not LocalPlayer then return false end
    if not player.Team or not LocalPlayer.Team then return false end
    return player.Team == LocalPlayer.Team
end

local function IsVisible(player)
    local char = GetCharacter(player)
    local myChar = GetCharacter(LocalPlayer)
    if not char or not myChar then return false end
    
    local targetPart = char:FindFirstChild("Head") or char:FindFirstChild("HumanoidRootPart")
    if not targetPart then return false end
    
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin)
    
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.FilterDescendantsInstances = {myChar, Camera}
    
    local result = workspace:Raycast(origin, direction, rayParams)
    
    if result then
        return result.Instance:IsDescendantOf(char)
    end
    return true
end

local function GetScreenPosition(position)
    local screenPos, onScreen = Camera:WorldToViewportPoint(position)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen, screenPos.Z
end

local function GetFOVOrigin()
    local viewport = Camera.ViewportSize
    return Vector2.new(viewport.X / 2, viewport.Y / 2)
end

local function GetClosestPlayer(settings)
    settings = settings or {}
    local maxDistance = settings.MaxDistance or PW.Visuals.FOVRadius or 500
    local targetPart = settings.TargetPart or "HumanoidRootPart"
    local visibleCheck = settings.VisibleCheck or false
    local teamCheck = settings.TeamCheck or false
    local aliveCheck = settings.AliveCheck or true
    
    local closest = nil
    local closestDistance = maxDistance
    local fovOrigin = GetFOVOrigin()
    
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        if teamCheck and IsTeammate(player) then continue end
        if aliveCheck and not IsAlive(player) then continue end
        if visibleCheck and not IsVisible(player) then continue end
        
        local char = GetCharacter(player)
        if not char then continue end
        
        local part = char:FindFirstChild(targetPart) or char:FindFirstChild("HumanoidRootPart")
        if not part then continue end
        
        local screenPos, onScreen = GetScreenPosition(part.Position)
        if not onScreen then continue end
        
        local distance = (fovOrigin - screenPos).Magnitude
        if distance < closestDistance then
            closestDistance = distance
            closest = {
                Player = player,
                Character = char,
                Part = part,
                Distance = distance,
                ScreenPos = screenPos,
            }
        end
    end
    
    return closest
end

local function GetPredictedPosition(part, prediction)
    if not part then return nil end
    local velocity = part.AssemblyLinearVelocity or Vector3.zero
    return part.Position + (velocity * (prediction or 0.165))
end

local function ApplyResolver(position, part)
    if not PW.Resolver.Enabled or not part then return position end
    
    local velocity = part.AssemblyLinearVelocity or Vector3.zero
    local intensity = PW.Resolver.Intensity
    
    if PW.Resolver.Method == "Velocity" then
        return position + (velocity * intensity * 0.1)
    elseif PW.Resolver.Method == "Randomize" then
        return position + Vector3.new(
            (math.random() - 0.5) * intensity,
            (math.random() - 0.5) * intensity * 0.5,
            (math.random() - 0.5) * intensity
        )
    elseif PW.Resolver.Method == "Invert" then
        return position - (velocity * intensity * 0.2)
    end
    
    return position
end

local function StartAimLock()
    Disconnect("AimLock")
    
    PW.Connections.AimLock = RunService.RenderStepped:Connect(function()
        if not PW.AimLock.Enabled then return end
        
        if not PW.AimLock.Locked or not PW.AimLock.Target then
            local closest = GetClosestPlayer({
                TargetPart = PW.AimLock.TargetPart,
                VisibleCheck = PW.AimLock.VisibleCheck,
                TeamCheck = PW.AimLock.TeamCheck,
                AliveCheck = PW.AimLock.AliveCheck,
                MaxDistance = PW.Visuals.FOVRadius,
            })
            
            if closest then
                PW.AimLock.Target = closest
                PW.AimLock.Locked = true
            end
            return
        end
        
        local target = PW.AimLock.Target
        if not target or not target.Player or not target.Player.Parent then
            PW.AimLock.Target = nil
            PW.AimLock.Locked = false
            return
        end
        
        if PW.AimLock.AliveCheck and not IsAlive(target.Player) then
            PW.AimLock.Target = nil
            PW.AimLock.Locked = false
            return
        end
        
        if PW.AimLock.VisibleCheck and not IsVisible(target.Player) then
            PW.AimLock.Target = nil
            PW.AimLock.Locked = false
            return
        end
        
        local char = GetCharacter(target.Player)
        if not char then
            PW.AimLock.Target = nil
            PW.AimLock.Locked = false
            return
        end
        
        local part = char:FindFirstChild(PW.AimLock.TargetPart) or char:FindFirstChild("Head")
        if not part then return end
        
        local predictedPos = GetPredictedPosition(part, PW.AimLock.Prediction)
        predictedPos = ApplyResolver(predictedPos, part)
        
        local currentCFrame = Camera.CFrame
        local targetCFrame = CFrame.new(currentCFrame.Position, predictedPos)
        
        local smoothness = math.clamp(PW.AimLock.Smoothness, 0.01, 1)
        Camera.CFrame = currentCFrame:Lerp(targetCFrame, smoothness)
    end)
end

local function StopAimLock()
    Disconnect("AimLock")
    PW.AimLock.Target = nil
    PW.AimLock.Locked = false
end

local function StartSilentAim()
    Disconnect("SilentAimUpdate")
    
    PW.Connections.SilentAimUpdate = RunService.Heartbeat:Connect(function()
        if not PW.SilentAim.Enabled then
            PW.SilentAim.Target = nil
            return
        end
        
        local closest = GetClosestPlayer({
            TargetPart = PW.SilentAim.TargetPart,
            VisibleCheck = PW.SilentAim.VisibleCheck,
            TeamCheck = PW.SilentAim.TeamCheck,
            AliveCheck = PW.SilentAim.AliveCheck,
            MaxDistance = PW.Visuals.FOVRadius,
        })
        
        PW.SilentAim.Target = closest
    end)
end

local function StartDesync()
    Disconnect("Desync")
    
    PW.Connections.Desync = RunService.Heartbeat:Connect(function()
        if not PW.Desync.Enabled then return end
        
        local char = GetCharacter(LocalPlayer)
        if not char then return end
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local intensity = PW.Desync.Intensity
        
        if PW.Desync.Mode == "Velocity" then
            local randomVel = Vector3.new(
                math.random(-100, 100) * intensity,
                0,
                math.random(-100, 100) * intensity
            )
            hrp.AssemblyLinearVelocity = hrp.AssemblyLinearVelocity + randomVel * 0.01
        elseif PW.Desync.Mode == "CFrame" then
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(math.random(-intensity, intensity)), 0)
        end
    end)
end

local function CreateFlySystem()
    local char = GetCharacter(LocalPlayer)
    if not char then return end
    
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then return end
    
    if PW.Movement.BodyVelocity then
        PW.Movement.BodyVelocity:Destroy()
    end
    if PW.Movement.BodyGyro then
        PW.Movement.BodyGyro:Destroy()
    end
    
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = Vector3.zero
    bv.Parent = hrp
    PW.Movement.BodyVelocity = bv
    
    local bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
    bg.P = 9e4
    bg.CFrame = hrp.CFrame
    bg.Parent = hrp
    PW.Movement.BodyGyro = bg
    
    hum.PlatformStand = true
end

local function DestroyFlySystem()
    local char = GetCharacter(LocalPlayer)
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then hum.PlatformStand = false end
    end
    
    if PW.Movement.BodyVelocity then
        PW.Movement.BodyVelocity:Destroy()
        PW.Movement.BodyVelocity = nil
    end
    if PW.Movement.BodyGyro then
        PW.Movement.BodyGyro:Destroy()
        PW.Movement.BodyGyro = nil
    end
end

local function StartFly()
    Disconnect("Fly")
    CreateFlySystem()
    
    PW.Connections.Fly = RunService.RenderStepped:Connect(function()
        if not PW.Movement.FlyEnabled then return end
        
        local char = GetCharacter(LocalPlayer)
        if not char then return end
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hrp or not hum then return end
        
        if not PW.Movement.BodyVelocity or not PW.Movement.BodyVelocity.Parent then
            CreateFlySystem()
        end
        
        local bv = PW.Movement.BodyVelocity
        local bg = PW.Movement.BodyGyro
        if not bv or not bg then return end
        
        local speed = PW.Movement.FlySpeed
        local direction = Vector3.zero
        
        if IsMobile then
            local moveDir = hum.MoveDirection
            if moveDir.Magnitude > 0 then
                direction = Camera.CFrame:VectorToWorldSpace(Vector3.new(moveDir.X, 0, -moveDir.Z).Unit)
            end
            
            local touchGui = LocalPlayer:FindFirstChild("PlayerGui")
            if touchGui then
                local jumpButton = touchGui:FindFirstChild("TouchGui")
                if jumpButton then
                    local jumping = hum.Jump
                    if jumping then
                        direction = direction + Vector3.new(0, 1, 0)
                    end
                end
            end
            
            if hum:GetState() == Enum.HumanoidStateType.Jumping then
                direction = direction + Vector3.new(0, 1, 0)
            end
        else
            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                direction = direction + Camera.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                direction = direction - Camera.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                direction = direction - Camera.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                direction = direction + Camera.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                direction = direction + Vector3.new(0, 1, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                direction = direction - Vector3.new(0, 1, 0)
            end
        end
        
        if direction.Magnitude > 0 then
            direction = direction.Unit
        end
        
        bv.Velocity = direction * speed
        bg.CFrame = Camera.CFrame
    end)
end

local function StopFly()
    Disconnect("Fly")
    DestroyFlySystem()
end

local function StartSpeed()
    Disconnect("Speed")
    
    PW.Connections.Speed = RunService.RenderStepped:Connect(function()
        if not PW.Movement.SpeedEnabled then return end
        
        local char = GetCharacter(LocalPlayer)
        if not char then return end
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hrp or not hum then return end
        
        if hum.MoveDirection.Magnitude > 0 then
            local moveDir = hum.MoveDirection.Unit
            hrp.CFrame = hrp.CFrame + (moveDir * PW.Movement.SpeedValue)
        end
    end)
end

local function StartNoClip()
    Disconnect("NoClip")
    
    PW.Connections.NoClip = RunService.Stepped:Connect(function()
        if not PW.Movement.NoClipEnabled then return end
        
        local char = GetCharacter(LocalPlayer)
        if not char then return end
        
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end)
end

local function StartInfiniteJump()
    Disconnect("InfiniteJump")
    
    PW.Connections.InfiniteJump = UserInputService.JumpRequest:Connect(function()
        if not PW.Movement.InfiniteJumpEnabled then return end
        
        local hum = GetHumanoid(LocalPlayer)
        if hum then
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)
end

local function ClearESP()
    for _, obj in pairs(PW.ESPObjects) do
        if obj then
            for _, drawing in pairs(obj) do
                if drawing and drawing.Remove then
                    pcall(function() drawing:Remove() end)
                end
            end
        end
    end
    PW.ESPObjects = {}
end

local function CreateESPForPlayer(player)
    if player == LocalPlayer then return end
    if PW.ESPObjects[player] then return end
    
    local esp = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        Health = Drawing.new("Line"),
        HealthBG = Drawing.new("Line"),
        Distance = Drawing.new("Text"),
    }
    
    esp.Box.Thickness = 1
    esp.Box.Filled = false
    esp.Box.Color = PW.Visuals.ESPColor
    esp.Box.Visible = false
    esp.Box.ZIndex = 2
    
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.Size = 13
    esp.Name.Font = Drawing.Fonts.Plex
    esp.Name.Color = Color3.new(1, 1, 1)
    esp.Name.Visible = false
    esp.Name.ZIndex = 3
    
    esp.HealthBG.Thickness = 3
    esp.HealthBG.Color = Color3.new(0, 0, 0)
    esp.HealthBG.Visible = false
    esp.HealthBG.ZIndex = 1
    
    esp.Health.Thickness = 1
    esp.Health.Color = Color3.new(0, 1, 0)
    esp.Health.Visible = false
    esp.Health.ZIndex = 2
    
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.Size = 12
    esp.Distance.Font = Drawing.Fonts.Plex
    esp.Distance.Color = Color3.new(0.8, 0.8, 0.8)
    esp.Distance.Visible = false
    esp.Distance.ZIndex = 3
    
    PW.ESPObjects[player] = esp
end

local function UpdateESP()
    for player, esp in pairs(PW.ESPObjects) do
        if not player or not player.Parent then
            for _, drawing in pairs(esp) do
                if drawing then drawing.Visible = false end
            end
            continue
        end
        
        if not PW.Visuals.ESPEnabled then
            for _, drawing in pairs(esp) do
                if drawing then drawing.Visible = false end
            end
            continue
        end
        
        if PW.Visuals.ESPTeamCheck and IsTeammate(player) then
            for _, drawing in pairs(esp) do
                if drawing then drawing.Visible = false end
            end
            continue
        end
        
        local char = GetCharacter(player)
        if not char then
            for _, drawing in pairs(esp) do
                if drawing then drawing.Visible = false end
            end
            continue
        end
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local head = char:FindFirstChild("Head")
        local hum = char:FindFirstChildOfClass("Humanoid")
        
        if not hrp or not head or not hum then
            for _, drawing in pairs(esp) do
                if drawing then drawing.Visible = false end
            end
            continue
        end
        
        local rootPos, onScreen = GetScreenPosition(hrp.Position)
        if not onScreen then
            for _, drawing in pairs(esp) do
                if drawing then drawing.Visible = false end
            end
            continue
        end
        
        local headPos = GetScreenPosition(head.Position + Vector3.new(0, 0.5, 0))
        local legPos = GetScreenPosition(hrp.Position - Vector3.new(0, 3, 0))
        
        local boxHeight = math.abs(headPos.Y - legPos.Y)
        local boxWidth = boxHeight / 2
        
        if PW.Visuals.ESPBox and esp.Box then
            esp.Box.Size = Vector2.new(boxWidth, boxHeight)
            esp.Box.Position = Vector2.new(rootPos.X - boxWidth / 2, headPos.Y)
            esp.Box.Color = PW.Visuals.ESPColor
            esp.Box.Visible = true
        else
            esp.Box.Visible = false
        end
        
        if PW.Visuals.ESPName and esp.Name then
            esp.Name.Text = player.DisplayName
            esp.Name.Position = Vector2.new(rootPos.X, headPos.Y - 15)
            esp.Name.Visible = true
        else
            esp.Name.Visible = false
        end
        
        if PW.Visuals.ESPHealth and esp.Health and esp.HealthBG then
            local healthPercent = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
            local barHeight = boxHeight * healthPercent
            local barX = rootPos.X - boxWidth / 2 - 5
            
            esp.HealthBG.From = Vector2.new(barX, legPos.Y)
            esp.HealthBG.To = Vector2.new(barX, headPos.Y)
            esp.HealthBG.Visible = true
            
            esp.Health.From = Vector2.new(barX, legPos.Y)
            esp.Health.To = Vector2.new(barX, legPos.Y - barHeight)
            esp.Health.Color = Color3.fromRGB(255 * (1 - healthPercent), 255 * healthPercent, 0)
            esp.Health.Visible = true
        else
            esp.Health.Visible = false
            esp.HealthBG.Visible = false
        end
        
        if PW.Visuals.ESPDistance and esp.Distance then
            local myHRP = GetRootPart(LocalPlayer)
            if myHRP then
                local dist = (hrp.Position - myHRP.Position).Magnitude
                esp.Distance.Text = string.format("[%dm]", math.floor(dist))
                esp.Distance.Position = Vector2.new(rootPos.X, legPos.Y + 3)
                esp.Distance.Visible = true
            end
        else
            esp.Distance.Visible = false
        end
    end
end

local function StartESP()
    Disconnect("ESP")
    Disconnect("ESPPlayerAdded")
    Disconnect("ESPPlayerRemoving")
    
    for _, player in pairs(Players:GetPlayers()) do
        CreateESPForPlayer(player)
    end
    
    PW.Connections.ESPPlayerAdded = Players.PlayerAdded:Connect(function(player)
        CreateESPForPlayer(player)
    end)
    
    PW.Connections.ESPPlayerRemoving = Players.PlayerRemoving:Connect(function(player)
        if PW.ESPObjects[player] then
            for _, drawing in pairs(PW.ESPObjects[player]) do
                if drawing then pcall(function() drawing:Remove() end) end
            end
            PW.ESPObjects[player] = nil
        end
    end)
    
    PW.Connections.ESP = RunService.RenderStepped:Connect(function()
        UpdateESP()
    end)
end

local function StopESP()
    Disconnect("ESP")
    Disconnect("ESPPlayerAdded")
    Disconnect("ESPPlayerRemoving")
    ClearESP()
end

local function CreateFOVCircle()
    if PW.Visuals.FOVCircle then
        PW.Visuals.FOVCircle:Remove()
    end
    
    local circle = Drawing.new("Circle")
    circle.Thickness = 1
    circle.NumSides = 64
    circle.Radius = PW.Visuals.FOVRadius
    circle.Filled = false
    circle.Visible = false
    circle.Color = PW.Visuals.FOVColor
    circle.Transparency = 1
    circle.ZIndex = 999
    
    PW.Visuals.FOVCircle = circle
end

local function StartFOVCircle()
    Disconnect("FOVCircle")
    CreateFOVCircle()
    
    PW.Connections.FOVCircle = RunService.RenderStepped:Connect(function()
        local circle = PW.Visuals.FOVCircle
        if not circle then return end
        
        circle.Visible = PW.Visuals.FOVEnabled
        circle.Radius = PW.Visuals.FOVRadius
        circle.Color = PW.Visuals.FOVColor
        circle.Position = GetFOVOrigin()
    end)
end

local function SaveLightingSettings()
    PW.World.OriginalLighting = {
        Ambient = Lighting.Ambient,
        Brightness = Lighting.Brightness,
        FogEnd = Lighting.FogEnd,
        FogStart = Lighting.FogStart,
        GlobalShadows = Lighting.GlobalShadows,
        OutdoorAmbient = Lighting.OutdoorAmbient,
    }
end

local function StartWorldTime()
    Disconnect("WorldTime")
    
    PW.Connections.WorldTime = RunService.Heartbeat:Connect(function()
        if PW.World.TimeEnabled then
            Lighting.ClockTime = PW.World.TimeValue
        end
    end)
end

local function ApplyFullbright()
    if PW.World.FullbrightEnabled then
        Lighting.Ambient = Color3.new(1, 1, 1)
        Lighting.Brightness = 2
        Lighting.GlobalShadows = false
        Lighting.OutdoorAmbient = Color3.new(1, 1, 1)
    else
        local orig = PW.World.OriginalLighting
        if orig.Ambient then
            Lighting.Ambient = orig.Ambient
            Lighting.Brightness = orig.Brightness
            Lighting.GlobalShadows = orig.GlobalShadows
            Lighting.OutdoorAmbient = orig.OutdoorAmbient
        end
    end
end

local function ApplyNoFog()
    if PW.World.NoFogEnabled then
        Lighting.FogEnd = 1e9
        Lighting.FogStart = 1e9
    else
        local orig = PW.World.OriginalLighting
        if orig.FogEnd then
            Lighting.FogEnd = orig.FogEnd
            Lighting.FogStart = orig.FogStart
        end
    end
end

local function StartAntiAFK()
    Disconnect("AntiAFK")
    
    local vu = game:GetService("VirtualUser")
    PW.Connections.AntiAFK = LocalPlayer.Idled:Connect(function()
        if PW.Misc.AntiAFKEnabled then
            vu:CaptureController()
            vu:ClickButton2(Vector2.new())
        end
    end)
end

local function ModifyWeapon(property, value)
    pcall(function()
        local char = GetCharacter(LocalPlayer)
        local backpack = LocalPlayer:FindFirstChild("Backpack")
        if not char or not backpack then return end
        
        local function apply(tool)
            if not tool or not tool:IsA("Tool") then return end
            
            pcall(function()
                tool:SetAttribute(property, value)
            end)
            
            for _, module in pairs(tool:GetDescendants()) do
                if module:IsA("ModuleScript") then
                    pcall(function()
                        local data = require(module)
                        if type(data) == "table" and data[property] ~= nil then
                            data[property] = value
                        end
                    end)
                end
            end
        end
        
        for _, item in pairs(backpack:GetChildren()) do
            apply(item)
        end
        
        local tool = char:FindFirstChildOfClass("Tool")
        if tool then apply(tool) end
    end)
end

SaveLightingSettings()
CreateFOVCircle()
StartFOVCircle()
StartSilentAim()
StartAntiAFK()
StartInfiniteJump()

pcall(function()
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if checkcaller() then return oldNamecall(self, ...) end
        if not PW.SilentAim.Enabled then return oldNamecall(self, ...) end
        if self ~= workspace then return oldNamecall(self, ...) end
        
        local target = PW.SilentAim.Target
        if not target or not target.Part then return oldNamecall(self, ...) end
        
        if math.random(1, 100) > PW.SilentAim.HitChance then
            return oldNamecall(self, ...)
        end
        
        local predictedPos = GetPredictedPosition(target.Part, PW.SilentAim.Prediction)
        if not predictedPos then return oldNamecall(self, ...) end
        
        if method == "Raycast" then
            local origin = args[1]
            if typeof(origin) == "Vector3" then
                local direction = (predictedPos - origin).Unit * 1000
                args[2] = direction
                return oldNamecall(self, unpack(args))
            end
        elseif method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist" then
            local ray = args[1]
            if typeof(ray) == "Ray" then
                local direction = (predictedPos - ray.Origin).Unit * 1000
                args[1] = Ray.new(ray.Origin, direction)
                return oldNamecall(self, unpack(args))
            end
        end
        
        return oldNamecall(self, ...)
    end))
end)

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Window = Library:CreateWindow({
    Title = "PasteWare",
    Footer = "Rewritten Edition | Mobile Ready",
    Icon = 95816097006870,
    NotifySide = "Right",
    ShowCustomCursor = not IsMobile,
    AutoShow = true,
})

local Tabs = {
    Aim = Window:AddTab("Aim", "crosshair"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Movement = Window:AddTab("Movement", "zap"),
    World = Window:AddTab("World", "sun"),
    Exploits = Window:AddTab("Exploits", "code"),
    Misc = Window:AddTab("Misc", "box"),
    Settings = Window:AddTab("Settings", "settings"),
}

local Options = Library.Options
local Toggles = Library.Toggles

local AimLockBox = Tabs.Aim:AddLeftGroupbox("AimLock")

AimLockBox:AddToggle("AimLockEnabled", {
    Text = "Enable AimLock",
    Default = false,
    Callback = function(Value)
        PW.AimLock.Enabled = Value
        if Value then
            StartAimLock()
        else
            StopAimLock()
        end
    end
}):AddKeyPicker("AimLockKey", {
    Default = "C",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "AimLock",
})

AimLockBox:AddSlider("AimSmooth", {
    Text = "Smoothness",
    Default = 0.15,
    Min = 0.01,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        PW.AimLock.Smoothness = Value
    end
})

AimLockBox:AddSlider("AimPrediction", {
    Text = "Prediction",
    Default = 0.165,
    Min = 0,
    Max = 0.5,
    Rounding = 3,
    Callback = function(Value)
        PW.AimLock.Prediction = Value
    end
})

AimLockBox:AddDropdown("AimPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = "Head",
    Text = "Target Part",
    Callback = function(Value)
        PW.AimLock.TargetPart = Value
    end
})

AimLockBox:AddToggle("AimVisCheck", {
    Text = "Visibility Check",
    Default = false,
    Callback = function(Value)
        PW.AimLock.VisibleCheck = Value
    end
})

AimLockBox:AddToggle("AimTeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(Value)
        PW.AimLock.TeamCheck = Value
    end
})

local SilentBox = Tabs.Aim:AddLeftGroupbox("Silent Aim")

SilentBox:AddToggle("SilentEnabled", {
    Text = "Enable Silent Aim",
    Default = false,
    Callback = function(Value)
        PW.SilentAim.Enabled = Value
    end
}):AddKeyPicker("SilentKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Silent Aim",
})

SilentBox:AddSlider("SilentPrediction", {
    Text = "Prediction",
    Default = 0.165,
    Min = 0,
    Max = 0.5,
    Rounding = 3,
    Callback = function(Value)
        PW.SilentAim.Prediction = Value
    end
})

SilentBox:AddSlider("HitChance", {
    Text = "Hit Chance",
    Default = 100,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Callback = function(Value)
        PW.SilentAim.HitChance = Value
    end
})

SilentBox:AddDropdown("SilentPart", {
    Values = {"Head", "HumanoidRootPart", "UpperTorso"},
    Default = "HumanoidRootPart",
    Text = "Target Part",
    Callback = function(Value)
        PW.SilentAim.TargetPart = Value
    end
})

SilentBox:AddToggle("SilentVisCheck", {
    Text = "Visibility Check",
    Default = false,
    Callback = function(Value)
        PW.SilentAim.VisibleCheck = Value
    end
})

SilentBox:AddToggle("SilentTeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(Value)
        PW.SilentAim.TeamCheck = Value
    end
})

local ResolverBox = Tabs.Aim:AddRightGroupbox("Resolver")

ResolverBox:AddToggle("ResolverEnabled", {
    Text = "Enable Resolver",
    Default = false,
    Callback = function(Value)
        PW.Resolver.Enabled = Value
    end
})

ResolverBox:AddSlider("ResolverIntensity", {
    Text = "Intensity",
    Default = 1.5,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Callback = function(Value)
        PW.Resolver.Intensity = Value
    end
})

ResolverBox:AddDropdown("ResolverMethod", {
    Values = {"Velocity", "Randomize", "Invert"},
    Default = "Velocity",
    Text = "Method",
    Callback = function(Value)
        PW.Resolver.Method = Value
    end
})

local DesyncBox = Tabs.Aim:AddRightGroupbox("Desync")

DesyncBox:AddToggle("DesyncEnabled", {
    Text = "Enable Desync",
    Default = false,
    Callback = function(Value)
        PW.Desync.Enabled = Value
        if Value then
            StartDesync()
        else
            Disconnect("Desync")
        end
    end
}):AddKeyPicker("DesyncKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Desync",
})

DesyncBox:AddSlider("DesyncIntensity", {
    Text = "Intensity",
    Default = 5,
    Min = 1,
    Max = 15,
    Rounding = 0,
    Callback = function(Value)
        PW.Desync.Intensity = Value
    end
})

DesyncBox:AddDropdown("DesyncMode", {
    Values = {"Velocity", "CFrame"},
    Default = "Velocity",
    Text = "Mode",
    Callback = function(Value)
        PW.Desync.Mode = Value
    end
})

local FOVBox = Tabs.Aim:AddRightGroupbox("FOV Circle")

FOVBox:AddToggle("FOVEnabled", {
    Text = "Show FOV",
    Default = false,
    Callback = function(Value)
        PW.Visuals.FOVEnabled = Value
    end
}):AddColorPicker("FOVColor", {
    Default = Color3.new(1, 1, 1),
    Callback = function(Value)
        PW.Visuals.FOVColor = Value
    end
})

FOVBox:AddSlider("FOVRadius", {
    Text = "Radius",
    Default = 150,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Callback = function(Value)
        PW.Visuals.FOVRadius = Value
    end
})

local ESPBox = Tabs.Visuals:AddLeftGroupbox("ESP")

ESPBox:AddToggle("ESPEnabled", {
    Text = "Enable ESP",
    Default = false,
    Callback = function(Value)
        PW.Visuals.ESPEnabled = Value
        if Value then
            StartESP()
        else
            StopESP()
        end
    end
}):AddColorPicker("ESPColor", {
    Default = Color3.fromRGB(255, 0, 255),
    Callback = function(Value)
        PW.Visuals.ESPColor = Value
    end
})

ESPBox:AddToggle("ESPBox", {
    Text = "Box",
    Default = true,
    Callback = function(Value)
        PW.Visuals.ESPBox = Value
    end
})

ESPBox:AddToggle("ESPName", {
    Text = "Name",
    Default = true,
    Callback = function(Value)
        PW.Visuals.ESPName = Value
    end
})

ESPBox:AddToggle("ESPHealth", {
    Text = "Health Bar",
    Default = true,
    Callback = function(Value)
        PW.Visuals.ESPHealth = Value
    end
})

ESPBox:AddToggle("ESPDistance", {
    Text = "Distance",
    Default = true,
    Callback = function(Value)
        PW.Visuals.ESPDistance = Value
    end
})

ESPBox:AddToggle("ESPTeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(Value)
        PW.Visuals.ESPTeamCheck = Value
    end
})

local MoveBox = Tabs.Movement:AddLeftGroupbox("Speed")

MoveBox:AddToggle("SpeedEnabled", {
    Text = "CFrame Speed",
    Default = false,
    Callback = function(Value)
        PW.Movement.SpeedEnabled = Value
        if Value then
            StartSpeed()
        else
            Disconnect("Speed")
        end
    end
}):AddKeyPicker("SpeedKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Speed",
})

MoveBox:AddSlider("SpeedValue", {
    Text = "Speed Value",
    Default = 2,
    Min = 0.5,
    Max = 10,
    Rounding = 1,
    Callback = function(Value)
        PW.Movement.SpeedValue = Value
    end
})

local FlyBox = Tabs.Movement:AddLeftGroupbox("Fly")

FlyBox:AddToggle("FlyEnabled", {
    Text = "Enable Fly",
    Default = false,
    Callback = function(Value)
        PW.Movement.FlyEnabled = Value
        if Value then
            StartFly()
        else
            StopFly()
        end
    end
}):AddKeyPicker("FlyKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Fly",
})

FlyBox:AddSlider("FlySpeed", {
    Text = "Fly Speed",
    Default = 50,
    Min = 10,
    Max = 200,
    Rounding = 0,
    Callback = function(Value)
        PW.Movement.FlySpeed = Value
    end
})

if IsMobile then
    FlyBox:AddLabel("Mobile: Use joystick to move")
    FlyBox:AddLabel("Jump button = Go up")
end

local NoClipBox = Tabs.Movement:AddRightGroupbox("NoClip")

NoClipBox:AddToggle("NoClipEnabled", {
    Text = "Enable NoClip",
    Default = false,
    Callback = function(Value)
        PW.Movement.NoClipEnabled = Value
        if Value then
            StartNoClip()
        else
            Disconnect("NoClip")
        end
    end
}):AddKeyPicker("NoClipKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "NoClip",
})

local JumpBox = Tabs.Movement:AddRightGroupbox("Infinite Jump")

JumpBox:AddToggle("InfJumpEnabled", {
    Text = "Infinite Jump",
    Default = false,
    Callback = function(Value)
        PW.Movement.InfiniteJumpEnabled = Value
    end
}):AddKeyPicker("InfJumpKey", {
    Default = "None",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Infinite Jump",
})

local WorldBox = Tabs.World:AddLeftGroupbox("Time")

WorldBox:AddToggle("TimeEnabled", {
    Text = "Lock Time",
    Default = false,
    Callback = function(Value)
        PW.World.TimeEnabled = Value
        if Value then
            StartWorldTime()
        else
            Disconnect("WorldTime")
        end
    end
})

WorldBox:AddSlider("TimeValue", {
    Text = "Time",
    Default = 12,
    Min = 0,
    Max = 24,
    Rounding = 1,
    Callback = function(Value)
        PW.World.TimeValue = Value
    end
})

local LightBox = Tabs.World:AddLeftGroupbox("Lighting")

LightBox:AddToggle("Fullbright", {
    Text = "Fullbright",
    Default = false,
    Callback = function(Value)
        PW.World.FullbrightEnabled = Value
        ApplyFullbright()
    end
})

LightBox:AddToggle("NoFog", {
    Text = "No Fog",
    Default = false,
    Callback = function(Value)
        PW.World.NoFogEnabled = Value
        ApplyNoFog()
    end
})

local ACSBox = Tabs.Exploits:AddLeftGroupbox("ACS Engine")

ACSBox:AddButton({
    Text = "Infinite Ammo",
    Func = function()
        ModifyWeapon("Ammo", math.huge)
        ModifyWeapon("StoredAmmo", math.huge)
        ModifyWeapon("MagSize", math.huge)
        Library:Notify({ Title = "ACS", Description = "Infinite Ammo Applied!", Time = 2 })
    end
})

ACSBox:AddButton({
    Text = "No Recoil",
    Func = function()
        ModifyWeapon("Recoil", 0)
        ModifyWeapon("VRecoil", Vector2.new(0, 0))
        ModifyWeapon("HRecoil", Vector2.new(0, 0))
        ModifyWeapon("KickBack", 0)
        ModifyWeapon("RecoilPunch", 0)
        Library:Notify({ Title = "ACS", Description = "No Recoil Applied!", Time = 2 })
    end
})

ACSBox:AddButton({
    Text = "No Spread",
    Func = function()
        ModifyWeapon("Spread", 0)
        ModifyWeapon("MinSpread", 0)
        ModifyWeapon("MaxSpread", 0)
        ModifyWeapon("HipSpread", 0)
        Library:Notify({ Title = "ACS", Description = "No Spread Applied!", Time = 2 })
    end
})

ACSBox:AddButton({
    Text = "Rapid Fire",
    Func = function()
        ModifyWeapon("FireRate", 1500)
        ModifyWeapon("ShootRate", 1500)
        ModifyWeapon("RPM", 1500)
        Library:Notify({ Title = "ACS", Description = "Rapid Fire Applied!", Time = 2 })
    end
})

ACSBox:AddButton({
    Text = "Infinite Range",
    Func = function()
        ModifyWeapon("Range", 99999)
        ModifyWeapon("Distance", 99999)
        ModifyWeapon("MaxDistance", 99999)
        Library:Notify({ Title = "ACS", Description = "Infinite Range Applied!", Time = 2 })
    end
})

ACSBox:AddButton({
    Text = "Instant Kill",
    Func = function()
        ModifyWeapon("Damage", 9999)
        ModifyWeapon("HeadDamage", 9999)
        ModifyWeapon("TorsoDamage", 9999)
        ModifyWeapon("LimbDamage", 9999)
        Library:Notify({ Title = "ACS", Description = "Instant Kill Applied!", Time = 2 })
    end
})

local MiscBox = Tabs.Misc:AddLeftGroupbox("Misc")

MiscBox:AddToggle("AntiAFK", {
    Text = "Anti AFK",
    Default = false,
    Callback = function(Value)
        PW.Misc.AntiAFKEnabled = Value
    end
})

MiscBox:AddButton({
    Text = "Rejoin Server",
    Func = function()
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
    end
})

MiscBox:AddButton({
    Text = "Server Hop",
    Func = function()
        local servers = {}
        local req = game:HttpGet("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100")
        local data = game:GetService("HttpService"):JSONDecode(req)
        for _, server in pairs(data.data) do
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                table.insert(servers, server.id)
            end
        end
        if #servers > 0 then
            game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], LocalPlayer)
        end
    end
})

MiscBox:AddButton({
    Text = "Copy Job ID",
    Func = function()
        if setclipboard then
            setclipboard(game.JobId)
            Library:Notify({ Title = "Copied", Description = "Job ID copied to clipboard!", Time = 2 })
        end
    end
})

local MenuBox = Tabs.Settings:AddLeftGroupbox("Menu")

MenuBox:AddToggle("Keybinds", {
    Text = "Show Keybinds",
    Default = false,
    Callback = function(Value)
        Library.KeybindFrame.Visible = Value
    end
})

MenuBox:AddLabel("Menu Keybind"):AddKeyPicker("MenuKey", {
    Default = "RightShift",
    NoUI = true,
    Text = "Menu",
})

MenuBox:AddButton({
    Text = "Unload Script",
    Func = function()
        Library:Unload()
    end
})

Library.ToggleKeybind = Options.MenuKey

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKey" })
ThemeManager:SetFolder("PasteWare")
SaveManager:SetFolder("PasteWare/Configs")
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

Library:OnUnload(function()
    DisconnectAll()
    ClearESP()
    DestroyFlySystem()
    
    if PW.Visuals.FOVCircle then
        PW.Visuals.FOVCircle:Remove()
    end
    
    getgenv().PasteWare = nil
end)

Library:Notify({
    Title = "PasteWare",
    Description = "Loaded Successfully! " .. (IsMobile and "(Mobile Mode)" or "(PC Mode)"),
    Time = 4
})

end)

if not success then
    warn("[PasteWare Error]", err)
end
